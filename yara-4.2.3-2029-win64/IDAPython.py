#-*- coding:utf-8 -*-
#识别循环，识别准则：要跳转的地址比当前地址小

def upper2lower(u):
    return chr(ord(u)+32)#ord获得字符的ASCII，chr将ASCII转为字符

def isJmp(addr):
    JMP_=['JO','JNO','JB','JNB','JE','JNE','JBE','JA','JS','JNS','JP','JNP','JL','JNL','JNG','JG','JCXZ','JECXZ','JMP','JMPE']
    for i in range(0,len(JMP_)):
        low=''
        for j in JMP_[i]:
            low+=upper2lower(j)
        JMP_.append(low)

    op=GetMnem(addr)#获取某地址处的指令
    if isCode(GetFlags(addr)):#GetFlags返回一个flags_t类型的实例可用来判断属于code还是data
        for j in JMP_:
            if j==op:
                return 1
    
    return 0

def isCircul(start,end):
    for addr in range(start,end):
        if isJmp(addr)==1:
            #获取跳转地址
            tmp=GetDisasm(addr)
            
            for i in range(0,len(tmp)-3):
                tmp1=tmp[i:i+4]
                
                if tmp1=="loc_":
                    tmp2=GetDisasm(addr)[i+4:i+10]#GetDisasm(addr)获得地址处的反汇编字符串(包括注释)，jmp指令通常为jz   short loc_40102B类型，无注释时后6位即为跳转的地址
                    #print(tmp2)
                    break
                #print(tmp)
            #成功得到跳转地址，判断与当前地址大小关系
            if int(tmp2,16)<addr:
                MakeComm(addr,"循环跳转指令")
                print "循环跳转指令: 0x%x"%(addr)
for seg in Segments():
    if SegName(seg) == '.text':
        isCircul(seg,SegEnd(seg))

